*motion.txt*    For Vim version 5.6.  Last change: 1999 Sep 17


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Cursor motions					*cursor-motions* *navigation*

These commands move the cursor position.  If the new position is off of the
screen, the screen is scrolled to show the cursor (see also 'scrolljump' and
'scrolloff' options).

1. Motions and operators	|operator|
2. Left-right motions		|left-right-motions|
3. Up-down motions		|up-down-motions|
4. Word motions			|word-motions|
5. Text object motions		|object-motions|
6. Text object selection	|object-select|
7. Various motions		|various-motions|

==============================================================================
1. motions and operators				*operator*

The motion commands can be used after an operator command, to have the command
operate on the text that was moved over.  That is the text between the cursor
position before and after the motion.  Operators are generally used to delete
or change text.  The following operators are available:

	|c|	c	change
	|d|	d	delete
	|y|	y	yank into register (does not change the text)
	|~|	~	swap case (only if 'tildeop' is set)
	|!|	!	filter through an external program
	|=|	=	filter through 'equalprg' or C-indenting if empty
	|gq|	gq	text formatting
	|Q|	Q	text formatting
	|>|	>	shift right
	|<|	<	shift left

If the motion includes a count and the operator also had a count before it,
the two counts are multiplied.  For example: "2d3w" deletes six words.

After applying the operator the cursor is mostly left at the start of the text
that was operated upon.  For example, "yfe" doesn't move the cursor, but "yFe"
moves the cursor leftwards to the "e" where the yank started.

						*linewise* *characterwise*
The operator either affects whole lines, or the characters between the start
and end position.  Generally, motions that move between lines affect lines
(are linewise), and motions that move within a line affect characters (are
characterwise).  However, there are some exceptions.

A character motion is either inclusive or exclusive. When inclusive, the start
and end position of the motion are included in the operation.  When exclusive,
the last character towards the end of the buffer is not included.  Linewise
motions always include the start and end position.

Which motions are linewise, inclusive or exclusive is mentioned below.  There
are however, two general exceptions:
1. If the motion is exclusive and the end of the motion is in column 1, the
   end of the motion is moved to the end of the previous line and the motion
   becomes inclusive.  Example: "}" ends at the first line after a paragraph,
   but "V}" will not include that line.
2. If the motion is exclusive, the end of the motion is in column 1 and the
   start of the motion was at or before the first non-blank in the line, the
   motion becomes linewise.  Example: If a paragraph begins with some blanks
   and you do "d}" while standing on the first non-blank, all the lines of
   the paragraph are deleted, including the blanks.  If you do a put now, the
   deleted lines will be inserted below the cursor position.

Note that when the operator is pending (the operator command is typed, but the
motion isn't yet), a special set of mappings can be used.  See |:omap|.

Instead of first giving the operator and then a motion you can use Visual
mode: mark the start of the text with "v", move the cursor to the end of the
text that is to be affected and then hit the operator.  The text between the
start and the cursor position is highlighted, so you can see what text will
be operated upon.  This allows much more freedom, but requires more key
strokes and has limited redo functionality.  See the chapter on Visual mode
|Visual-mode|.

If you want to know where you are in the file use the "CTRL-G" command
|CTRL-G| or the "g CTRL-G" command |g_CTRL-G|.  If you set the 'ruler' option,
the cursor position is continuously shown in the status line (which slows down
Vim a little).

NOTE: Experienced users prefer the hjkl keys because they are always right
under their fingers.  Beginners often prefer the arrow keys, because they
do not know what the hjkl keys do.  The mnemonic value of hjkl is clear from
looking at the keyboard.  Think of j as an arrow pointing downwards.

==============================================================================
2. Left-right motions					*left-right-motions*

These commands move the cursor to the specified column in the current line.
They stop at the first column and at the end of the line, except "$", which
may move to one of the next lines.  See 'whichwrap' option to make some of the
commands move across line boundaries.

#*# table:form=ref:label=left-right-motions 1:command 3:extra-or 25:desc #*#
h		or					*h*
<Left>		or					*<Left>*
CTRL-H		or					*CTRL-H* *<BS>*
<BS>			[count] characters to the left |exclusive|.
			Note: If you prefer <BS> to delete a character, use
			the mapping:
				:map CTRL-V<BS>		X
			(to enter "CTRL-V<BS>" type the CTRL-V key, followed
			by the <BS> key)
			See |:fixdel| if the <BS> key does not do what you
			want.

l		or					*l*
<Right>		or					*<Right>* *<Space>*
<Space>			[count] characters to the right |exclusive|.

							*0*
0			To the first character of the line |exclusive|.  When
			moving up or down, stay in same screen column (if
			possible).

							*<Home>* *<kHome>*
<Home>			To the first character of the line |exclusive|.  When
			moving up or down, stay in same text column (if
			possible).  Works like "1|", which differs from "0"
			when the line starts with a <Tab>.  {not in Vi}

							*^*
^			To the first non-blank character of the line
			|exclusive|.

							*$* *<End>* *<kEnd>*
$  or <End>		To the end of the line and [count - 1] lines downward
			(inclusive).

							*g0* *g<Home>*
g0 or g<Home>		When lines wrap ('wrap' on): To the first character of
			the screen line.  |exclusive| motion.  Differs from
			"0" when a line is wider than the screen.
			When lines don't wrap ('wrap' off): To the leftmost
			character of the current line that is on the screen.
			Differs from "0" when the first character of the line
			is not on the screen.  {not in Vi}

							*g^*
g^			When lines wrap ('wrap' on): To the first non-blank
			character of the screen line.  |exclusive| motion.
			Differs from "^" when a line is wider than the screen.
			When lines don't wrap ('wrap' off): To the leftmost
			non-blank character of the current line that is on the
			screen.  Differs from "^" when the first non-blank
			character of the line is not on the screen.  {not in
			Vi}

							*gm*
gm			Like "g0", but half a screenwidth to the right (or as
			much as possible). {not in Vi}

							*g$* *g<End>*
g$ or g<End>		When lines wrap ('wrap' on): To the last character of
			the screen line and [count - 1] screen lines downward
			|inclusive|.  Differs from "$" when a line is wider
			than the screen.
			When lines don't wrap ('wrap' off): To the rightmost
			character of the current line that is visible on the
			screen.  Differs from "$" when the last character of
			the line is not on the screen or when a count is used.
			Additionally, vertical movements keep the column,
			instead of going to the end of the line.
			{not in Vi}

							*bar*
|			To screen column [count] in the current line
			|exclusive|.

							*f*
f{char}			To [count]'th occurrence of {char} to the right.  The
			cursor is placed on {char} (inclusive).

							*F*
F{char}			To the [count]'th occurrence of {char} to the left.
			The cursor is placed on {char} (inclusive).

							*t*
t{char}			Till before [count]'th occurrence of {char} to the
			right.  The cursor is placed on the character left of
			{char} (inclusive).

							*T*
T{char}			Till after [count]'th occurrence of {char} to the
			left.  The cursor is placed on the character right of
			{char} (inclusive).

							*;*
;			Repeat latest f, t, F or T [count] times.

							*,*
,			Repeat latest f, t, F or T in opposite direction
			[count] times.
#*#table:stop-table #*#

These commands move the cursor to the specified column in the current line.
They stop at the first column and at the end of the line, except "$", which
may move to one of the next lines.  See 'whichwrap' option to make some of the
commands move across line boundaries.

==============================================================================
3. Up-down motions					*up-down-motions*

#*# table:form=ref:label=up-down-motions 1:command 5:extra-or 25:desc #*#
k		or					*k*
<Up>		or					*<Up>* *CTRL-P*
CTRL-P			[count] lines upward (linewise).

j		or					*j*
<Down>		or					*<Down>*
CTRL-J		or					*CTRL-J*
<NL>		or					*<NL>* *CTRL-N*
CTRL-N			[count] lines downward (linewise).

gk		or					*gk* *g<Up>*
g<Up>			[count] display lines upward.  |exclusive| motion.
			Differs from 'k' when lines wrap, and when used with
			an operator, because it's not linewise.  {not in Vi}

gj		or					*gj* *g<Down>*
g<Down>			[count] display lines downward.  |exclusive| motion.
			Differs from 'j' when lines wrap, and when used with
			an operator, because it's not linewise.  {not in Vi}

							*-*
-  <minus>		[count] lines upward, on the first non-blank
			character (linewise).

+		or					*+*
CTRL-M		or					*CTRL-M* *<CR>*
<CR>			[count] lines downward, on the first non-blank
			character (linewise).

							*_*
_  <underscore>		[count] - 1 lines downward, on the first non-blank
			character (linewise).

<C-End>		or					*G* *<C-End>*
G			Goto line [count], default last line, on the first
			non-blank character (linewise).  If 'startofline' not
			set, keep the same column.

:[range]		Set the cursor on the last line number in [range].
			[range] can also be just one line number, e.g., ":1"
			or ":'m".
			In contrast with |G| this command does not modify the
			|jumplist|.

							*N%*
{count}%		Go to {count} percentage in the file, on the first
			non-blank in the line (linewise).  To compute the new
			line number this formula is used: {count} *
			number-of-lines / 100.  See also 'startofline'
			option.  {not in Vi}
#*#table:stop-table #*#

These commands move to the specified line.  They stop when reaching the first
or the last line.  The first two commands put the cursor in the same column
(if possible) as it was after the last command that changed the column,
except after the "$" command, then the cursor will be put on the last
character of the line.

==============================================================================
4. Word motions						*word-motions*

#*# table:form=ref:label=word-motions 1:command 3:extra-or 25:desc #*#
<S-Right>	or					*<S-Right>* *w*
w			[count] words forward (exclusive).

<C-Right>	or					*<C-Right>* *W*
W			[count] WORDS forward (exclusive).

							*e*
e			Forward to the end of word [count] (inclusive).

							*E*
E			Forward to the end of WORD [count] (inclusive).

<S-Left>	or					*<S-Left>* *b*
b			[count] words backward (exclusive).

<C-Left>	or					*<C-Left>* *B*
B			[count] WORDS backward (exclusive).

							*ge*
ge			Backward to the end of word [count] |inclusive|.

							*gE*
gE			Backward to the end of WORD [count] |inclusive|.
#*#table:stop-table #*#

These commands move over words or WORDS.
							*word*
A word consists of a sequence of letters, digits and underscores, or a
sequence of other non-blank characters, separated with white space (spaces,
tabs, <EOL>).  This can be changed with the 'iskeyword' option.
							*WORD*
A WORD consists of a sequence of non-blank characters, separated with white
space.  An empty line is also considered to be a word and a WORD.

Special case: "cw" and "cW" are treated like "ce" and "cE" if the cursor is
on a non-blank.  This is because "cw" is interpreted as change-word, and a
word does not include the following white space.  {Vi: "cw" when on a blank
followed by other blanks changes only the first blank; this is probably a
bug, because "dw" deletes all the blanks}

Another special case: When using the "w" motion in combination with an
operator and the last word moved over is at the end of a line, the end of
that word becomes the end of the operated text, not the first word in the
next line.

The original Vi implementation of "e" is buggy.  For example, the "e" command
will stop on the first character of a line if the previous line was empty.
But when you use "2e" this does not happen.  In Vim "ee" and "2e" are the
same, which is more logical.  However, this causes a small incompatibility
between Vi and Vim.

==============================================================================
5. Text object motions					*object-motions*

							*(*
(			[count] sentences backward (exclusive).

							*)*
)			[count] sentences forward (exclusive).

							*{*
{			[count] paragraphs backward (exclusive).

							*}*
}			[count] paragraphs forward (exclusive).

These commands move over three kinds of text objects.

							*sentence*
A sentence is defined as ending at a '.', '!' or '?' followed by either the
end of a line, or by a space or tab.  Any number of closing ')', ']', '"'
and ''' characters my appear after the '.', '!' or '?' before the spaces,
tabs or end of line.  A paragraph and section boundary is also a sentence
boundary.
If the 'J' flag is present is 'cpoptions', at least two spaces have to
follow the punctuation mark; <Tab>s are not recognized as white space.
The definition of a sentence cannot be changed.

							*paragraph*
A paragraph begins after each empty line.

==============================================================================
6. Text object selection			*object-select* *text-objects*
						*v_a* *v_i*

This is a series of commands that can only be used while in Visual mode or
after an operator.  The commands that start with "a" select "a"n object
including white space, the commands starting with "i" select an "inner" object
without white space, or just the white space.  Thus the "inner" commands
always select less text than the "a" commands.

These commands are {not in Vi}.
These commands are not available when the |+textobjects| feature has been
disabled at compile time.
							*v_aw* *aw*
aw			"a word", select [count] words (see |word|).
			Leading or trailing white space is included, but not
			counted.
			When used in Visual linewise mode "aw" switches to
			Visual characterwise mode.

							*v_iw* *iw*
iw			"inner word", select [count] words (see |word|).
			White space between words is counted too.
			When used in Visual linewise mode "iw" switches to
			Visual characterwise mode.

							*v_aW* *aW*
aW			"a WORD", select [count] WORDs (see |WORD|).
			Leading or trailing white space is included, but not
			counted.
			When used in Visual linewise mode "aW" switches to
			Visual characterwise mode.

							*v_iW* *iW*
iW			"inner WORD", select [count] WORDs (see |WORD|).
			White space between words is counted too.
			When used in Visual linewise mode "iW" switches to
			Visual characterwise mode.

							*v_as* *as*
as			"a sentence", select [count] sentences (see
			|sentence|).
			When used in Visual mode it is made characterwise.

							*v_is* *is*
is			"inner sentence", select [count] sentences (see
			|sentence|).
			When used in Visual mode it is made characterwise.

							*v_ap* *ap*
ap			"a paragraph", select [count] paragraphs (see
			|paragraph|).
			Exception: a blank line (only containing white space)
			is also a paragraph boundary.
			When used in Visual mode it is made linewise.

							*v_ip* *ip*
ip			"inner paragraph", select [count] paragraphs (see
			|paragraph|).
			Exception: a blank line (only containing white space)
			is also a paragraph boundary.
			When used in Visual mode it is made linewise.

a]						*v_a]* *v_a[* *a]* *a[*
a[			"a [] block", select [count] '[' ']' blocks.  This
			goes backwards to the [count] unclosed '[', and finds
			the matching ']'.  The enclosed text is selected,
			including the '[' and ']'.
			When used in Visual mode it is made characterwise.

i]						*v_i]* *v_i[* *i]* *i[*
i[			"inner [] block", select [count] '[' ']' blocks.  This
			goes backwards to the [count] unclosed '[', and finds
			the matching ']'.  The enclosed text is selected,
			excluding the '[' and ']'.
			When used in Visual mode it is made characterwise.

a)							*v_a)* *a)* *a(*
a(							*v_ab* *v_a(* *ab*
ab			"a block", select [count] blocks, from "[count] [(" to
			the matching ')', including the '(' and ')' (see
			|[(|).  Does not include white space outside of the
			parenthesis.
			When used in Visual mode it is made characterwise.

i)							*v_i)* *i)* *i(*
i(							*v_ib* *v_i(* *ib*
ib			"inner block", select [count] blocks, from "[count] [("
			to the matching ')', excluding the '(' and ')' (see
			|[(|).
			When used in Visual mode it is made characterwise.

a>						*v_a>* *v_a<* *a>* *a<*
a<			"a <> block", select [count] <> blocks, from the
			[count]'th unmatched '<' backwards to the matching
			'>', including the '<' and '>'.
			When used in Visual mode it is made characterwise.

i>						*v_i>* *v_i<* *i>* *i<*
i<			"inner <> block", select [count] <> blocks, from
			the [count]'th unmatched '<' backwards to the matching
			'>', excluding the '<' and '>'.
			When used in Visual mode it is made characterwise.

						*v_at* *at*
at			"a tag block", select [count] tag blocks, from the
			[count]'th unmatched "<aaa>" backwards to the matching
			"</aaa>", including the "<aaa>" and "</aaa>".
			See |tag-blocks| about the details.
			When used in Visual mode it is made characterwise.

						*v_it* *it*
it			"inner tag block", select [count] tag blocks, from the
			[count]'th unmatched "<aaa>" backwards to the matching
			"</aaa>", excluding the "<aaa>" and "</aaa>".
			See |tag-blocks| about the details.
			When used in Visual mode it is made characterwise.

a}							*v_a}* *a}* *a{*
a{							*v_aB* *v_a{* *aB*
aB			"a Block", select [count] Blocks, from "[count] [{" to
			the matching '}', including the '{' and '}' (see
			|[{|).
			When used in Visual mode it is made characterwise.

i}							*v_i}* *i}* *i{*
i{							*v_iB* *v_i{* *iB*
iB			"inner Block", select [count] Blocks, from "[count] [{"
			to the matching '}', excluding the '{' and '}' (see
			|[{|).
			When used in Visual mode it is made characterwise.

a"							*v_aquote* *aquote*
a'							*v_a'* *a'*
a`							*v_a`* *a`*
			"a quoted string".  Selects the text from the previous
			quote until the next quote.  The 'quoteescape' option
			is used to skip escaped quotes.
			Only works within one line.
			When the cursor starts on a quote, Vim will figure out
			which quote pairs form a string by searching from the
			start of the line.
			Any trailing or leading white space is included.
			When used in Visual mode it is made characterwise.
			Repeating this object in Visual mode another string is
			included.  A count is currently not used.

i"							*v_iquote* *iquote*
i'							*v_i'* *i'*
i`							*v_i`* *i`*
			Like a", a' and a`, but exclude the quotes and
			repeating won't extend the Visual selection.
			Special case: With a count of 2 the quotes are
			included, but no extra white space as with a"/a'/a`.

When used after an operator:
For non-block objects:
	For the "a" commands: The operator applies to the object and the white
	space after the object.  If there is no white space after the object
	or when the cursor was in the white space before the object, the white
	space before the object is included.
	For the "inner" commands: If the cursor was on the object, the
	operator applies to the object.  If the cursor was on white space, the
	operator applies to the white space.
For a block object:
	The operator applies to the block where the cursor is in, or the block
	on which the cursor is on one of the braces.  For the "inner" commands
	the surrounding braces are excluded.  For the "a" commands, the braces
	are included.

When used in Visual mode:
When start and end of the Visual area are the same (just after typing "v"):
	One object is selected, the same as for using an operator.
When start and end of the Visual area are not the same:
	For non-block objects the area is extended by one object or the white
	space up to the next object, or both for the "a" objects.  The
	direction in which this happens depends on which side of the Visual
	area the cursor is.  For the block objects the block is extended one
	level outwards.

For illustration, here is a list of delete commands, grouped from small to big
objects.  Note that for a single character and a whole line the existing vi
movement commands are used.
	"dl"	delete character (alias: "x")		|dl|
	"diw"	delete inner word			*diw*
	"daw"	delete a word				*daw*
	"diW"	delete inner WORD (see |WORD|)		*diW*
	"daW"	delete a WORD (see |WORD|)		*daW*
	"dd"	delete one line				|dd|
	"dis"	delete inner sentence			*dis*
	"das"	delete a sentence			*das*
	"dib"	delete inner '(' ')' block		*dib*
	"dab"	delete a '(' ')' block			*dab*
	"dip"	delete inner paragraph			*dip*
	"dap"	delete a paragraph			*dap*
	"diB"	delete inner '{' '}' block		*diB*
	"daB"	delete a '{' '}' block			*daB*

Note the difference between using a movement command and an object.  The
movement command operates from here (cursor position) to where the movement
takes us.  When using an object the whole object is operated upon, no matter
where on the object the cursor is.  For example, compare "dw" and "daw": "dw"
deletes from the cursor position to the start of the next word, "daw" deletes
the word under the cursor and the space after or before it.

==============================================================================
7. Various motions				*various-motions*

						*m* *mark* *Mark*
m{a-zA-Z}		Set mark {a-zA-Z} at cursor position (does not move
			the cursor, this is not a motion command).

m'  or  m`		Set the previous context mark.  This can be jumped to
			with the "''" or "``" command (does not move the
			cursor, this is not a motion command).

m.			Toggle an an anonymous mark on the current line.
			IDE's can set/clear "bookmarks" on a line.  This
			command depends on platform functionality. {jVi only}

m{<>}			To the previous, next anonymous mark.  This command
			depends on platform functionality. {jVi only}

						*'* *'a*
'{a-z}			To the first non-blank character on the line with
			mark {a-z} (linewise).
						*'A* *'0*
'{A-Z0-9}		To the first non-blank character on the line with
			mark {A-Z0-9} in the correct file (linewise when in
			same file, not a motion command when in other file).
			{not in Vi}

						*`* *`a*
`{a-z}			To the mark {a-z} (exclusive).
						*`A* *`0*
`{A-Z0-9}		To the mark {A-Z0-9} in the correct file (exclusive
			when in same file, not a motion command when in
			other file).  {not in Vi}

A mark is not visible in any way.  It is just a position in the file that is
remembered.  Do not confuse marks with named registers, they are totally
unrelated.

'a - 'z		lowercase marks, valid within one file
'A - 'Z		uppercase marks, also called file marks, valid between files
'0 - '9		numbered marks, set from .viminfo file

Lowercase marks 'a to 'z are remembered as long as the file remains in the
buffer list.  If you remove the file from the buffer list, all its marks are
lost.  If you delete a line that contains a mark, that mark is erased.
Lowercase marks can be used in combination with operators.  For example: "d't"
deletes the lines from the cursor position to mark 't'.  Hint: Use mark 't' for
Top, 'b' for Bottom, etc..  Lowercase marks are restored when using undo and
redo.

Numbered marks '0 to '9 are quite different.  They can not be set directly.
They are only present when using a viminfo file |viminfo-file|.  Basically '0
is the location of the cursor when you last exited Vim, '1 the last but one
time, etc.  See |viminfo-file-marks|.

							*'<*
'<			To the first non-blank character on the first line
			of the last selected Visual area in the current
			buffer.  {not in Vi}.

							*`<*
`<			To the first character of the last selected Visual
			area in the current buffer.  {not in Vi}.

							*'>*
'>			To the first non-blank character on the last line
			of the last selected Visual area in the current
			buffer.  {not in Vi}.

							*`>*
`>			To the last character of the last selected Visual
			area in the current buffer.  {not in Vi}.

							*''*
''			To the first non-blank character of the line where
			the cursor was before the latest jump, or where the
			last "m'" or "m`" command was given (linewise).

							*``*
``			To the position before latest jump, or where the last
			"m'" or "m`" command was given (exclusive).

A "jump" is one of the following commands: "'", "`", "G", "/", "?", "n",
"N", "%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H" and
the commands that start editing a new file.  If you make the cursor "jump"
with one of these commands, the position of the cursor before the jump is
remembered.  You can return to that position with the "''" and "``" command,
unless the line containing that position was changed or deleted.

							*%*
%			Find the next item in this line after or under the
			cursor and jump to its match (inclusive).  Items can
			be:
			([{}])		parenthesis or (curly/square) brackets
					(this can be changed with the
					'matchpairs' option)
			/* */		start or end of C-style comment
			#if, #ifdef, #else, #elif, #endif
					C preprocessor conditionals
			Parens and braces preceded with a backslash are
			ignored.  When the '%' character is not present in
			'cpoptions', parens and braces inside double quotes
			are ignored, unless the number of parens/braces in a
			line is uneven and this line and the previous one does
			not end in a backslash.  '(', '{', '[', ']', '}' and
			')' are also ignored (parens and braces inside single
			quotes).  Note that this works fine for C, but not for
			Perl, where single quotes are used for strings.
			No count is allowed ({count}% jumps to a line {count}
			percentage down the file).  Using '%' on
			#if/#else/#endif makes the movement linewise.

                        {jVi an extended mode that uses the platforms brace
                        matching algorithms may be available}

						*H*
H			To line [count] from top (Home) of screen (default:
			first line on the screen) on the first non-blank
			character (linewise).  See also 'startofline' option.
			Cursor is adjusted for 'scrolloff' option.

						*M*
M			To Middle line of screen, on the first non-blank
			character (linewise).  See also 'startofline' option.

						*L*
L			To line [count] from bottom of screen (default: Last
			line on the screen) on the first non-blank character
			(linewise).  See also 'startofline' option.
			Cursor is adjusted for 'scrolloff' option.

<LeftMouse>		Moves to the position on the screen where the mouse
			click is (inclusive).  See also |<LeftMouse>|.  If the
			position is in a status line, that window is made the
			active window and the cursor is not moved.  {not in Vi}

 vim:tw=78:ts=8:sw=8: 
